/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "m3/thrift/m3_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace tally { namespace m3 { namespace thrift {


CountValue::~CountValue() throw() {
}


void CountValue::__set_i64Value(const int64_t val) {
  this->i64Value = val;
__isset.i64Value = true;
}
std::ostream& operator<<(std::ostream& out, const CountValue& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CountValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->i64Value);
          this->__isset.i64Value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CountValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CountValue");

  if (this->__isset.i64Value) {
    xfer += oprot->writeFieldBegin("i64Value", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->i64Value);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CountValue &a, CountValue &b) {
  using ::std::swap;
  swap(a.i64Value, b.i64Value);
  swap(a.__isset, b.__isset);
}

CountValue::CountValue(const CountValue& other0) {
  i64Value = other0.i64Value;
  __isset = other0.__isset;
}
CountValue& CountValue::operator=(const CountValue& other1) {
  i64Value = other1.i64Value;
  __isset = other1.__isset;
  return *this;
}
void CountValue::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CountValue(";
  out << "i64Value="; (__isset.i64Value ? (out << to_string(i64Value)) : (out << "<null>"));
  out << ")";
}


GaugeValue::~GaugeValue() throw() {
}


void GaugeValue::__set_i64Value(const int64_t val) {
  this->i64Value = val;
__isset.i64Value = true;
}

void GaugeValue::__set_dValue(const double val) {
  this->dValue = val;
__isset.dValue = true;
}
std::ostream& operator<<(std::ostream& out, const GaugeValue& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GaugeValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->i64Value);
          this->__isset.i64Value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->dValue);
          this->__isset.dValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GaugeValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GaugeValue");

  if (this->__isset.i64Value) {
    xfer += oprot->writeFieldBegin("i64Value", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->i64Value);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dValue) {
    xfer += oprot->writeFieldBegin("dValue", ::apache::thrift::protocol::T_DOUBLE, 2);
    xfer += oprot->writeDouble(this->dValue);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GaugeValue &a, GaugeValue &b) {
  using ::std::swap;
  swap(a.i64Value, b.i64Value);
  swap(a.dValue, b.dValue);
  swap(a.__isset, b.__isset);
}

GaugeValue::GaugeValue(const GaugeValue& other2) {
  i64Value = other2.i64Value;
  dValue = other2.dValue;
  __isset = other2.__isset;
}
GaugeValue& GaugeValue::operator=(const GaugeValue& other3) {
  i64Value = other3.i64Value;
  dValue = other3.dValue;
  __isset = other3.__isset;
  return *this;
}
void GaugeValue::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GaugeValue(";
  out << "i64Value="; (__isset.i64Value ? (out << to_string(i64Value)) : (out << "<null>"));
  out << ", " << "dValue="; (__isset.dValue ? (out << to_string(dValue)) : (out << "<null>"));
  out << ")";
}


TimerValue::~TimerValue() throw() {
}


void TimerValue::__set_i64Value(const int64_t val) {
  this->i64Value = val;
__isset.i64Value = true;
}

void TimerValue::__set_dValue(const double val) {
  this->dValue = val;
__isset.dValue = true;
}
std::ostream& operator<<(std::ostream& out, const TimerValue& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TimerValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->i64Value);
          this->__isset.i64Value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->dValue);
          this->__isset.dValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TimerValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TimerValue");

  if (this->__isset.i64Value) {
    xfer += oprot->writeFieldBegin("i64Value", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->i64Value);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dValue) {
    xfer += oprot->writeFieldBegin("dValue", ::apache::thrift::protocol::T_DOUBLE, 2);
    xfer += oprot->writeDouble(this->dValue);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TimerValue &a, TimerValue &b) {
  using ::std::swap;
  swap(a.i64Value, b.i64Value);
  swap(a.dValue, b.dValue);
  swap(a.__isset, b.__isset);
}

TimerValue::TimerValue(const TimerValue& other4) {
  i64Value = other4.i64Value;
  dValue = other4.dValue;
  __isset = other4.__isset;
}
TimerValue& TimerValue::operator=(const TimerValue& other5) {
  i64Value = other5.i64Value;
  dValue = other5.dValue;
  __isset = other5.__isset;
  return *this;
}
void TimerValue::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TimerValue(";
  out << "i64Value="; (__isset.i64Value ? (out << to_string(i64Value)) : (out << "<null>"));
  out << ", " << "dValue="; (__isset.dValue ? (out << to_string(dValue)) : (out << "<null>"));
  out << ")";
}


MetricValue::~MetricValue() throw() {
}


void MetricValue::__set_count(const CountValue& val) {
  this->count = val;
__isset.count = true;
}

void MetricValue::__set_gauge(const GaugeValue& val) {
  this->gauge = val;
__isset.gauge = true;
}

void MetricValue::__set_timer(const TimerValue& val) {
  this->timer = val;
__isset.timer = true;
}
std::ostream& operator<<(std::ostream& out, const MetricValue& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MetricValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->count.read(iprot);
          this->__isset.count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->gauge.read(iprot);
          this->__isset.gauge = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->timer.read(iprot);
          this->__isset.timer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MetricValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MetricValue");

  if (this->__isset.count) {
    xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->count.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.gauge) {
    xfer += oprot->writeFieldBegin("gauge", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->gauge.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timer) {
    xfer += oprot->writeFieldBegin("timer", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->timer.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MetricValue &a, MetricValue &b) {
  using ::std::swap;
  swap(a.count, b.count);
  swap(a.gauge, b.gauge);
  swap(a.timer, b.timer);
  swap(a.__isset, b.__isset);
}

MetricValue::MetricValue(const MetricValue& other6) {
  count = other6.count;
  gauge = other6.gauge;
  timer = other6.timer;
  __isset = other6.__isset;
}
MetricValue& MetricValue::operator=(const MetricValue& other7) {
  count = other7.count;
  gauge = other7.gauge;
  timer = other7.timer;
  __isset = other7.__isset;
  return *this;
}
void MetricValue::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MetricValue(";
  out << "count="; (__isset.count ? (out << to_string(count)) : (out << "<null>"));
  out << ", " << "gauge="; (__isset.gauge ? (out << to_string(gauge)) : (out << "<null>"));
  out << ", " << "timer="; (__isset.timer ? (out << to_string(timer)) : (out << "<null>"));
  out << ")";
}


MetricTag::~MetricTag() throw() {
}


void MetricTag::__set_tagName(const std::string& val) {
  this->tagName = val;
}

void MetricTag::__set_tagValue(const std::string& val) {
  this->tagValue = val;
__isset.tagValue = true;
}
std::ostream& operator<<(std::ostream& out, const MetricTag& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MetricTag::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tagName);
          this->__isset.tagName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tagValue);
          this->__isset.tagValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MetricTag::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MetricTag");

  xfer += oprot->writeFieldBegin("tagName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->tagName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.tagValue) {
    xfer += oprot->writeFieldBegin("tagValue", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->tagValue);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MetricTag &a, MetricTag &b) {
  using ::std::swap;
  swap(a.tagName, b.tagName);
  swap(a.tagValue, b.tagValue);
  swap(a.__isset, b.__isset);
}

MetricTag::MetricTag(const MetricTag& other8) {
  tagName = other8.tagName;
  tagValue = other8.tagValue;
  __isset = other8.__isset;
}
MetricTag& MetricTag::operator=(const MetricTag& other9) {
  tagName = other9.tagName;
  tagValue = other9.tagValue;
  __isset = other9.__isset;
  return *this;
}
void MetricTag::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MetricTag(";
  out << "tagName=" << to_string(tagName);
  out << ", " << "tagValue="; (__isset.tagValue ? (out << to_string(tagValue)) : (out << "<null>"));
  out << ")";
}


Metric::~Metric() throw() {
}


void Metric::__set_name(const std::string& val) {
  this->name = val;
}

void Metric::__set_metricValue(const MetricValue& val) {
  this->metricValue = val;
__isset.metricValue = true;
}

void Metric::__set_timestamp(const int64_t val) {
  this->timestamp = val;
__isset.timestamp = true;
}

void Metric::__set_tags(const std::set<MetricTag> & val) {
  this->tags = val;
__isset.tags = true;
}
std::ostream& operator<<(std::ostream& out, const Metric& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Metric::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->metricValue.read(iprot);
          this->__isset.metricValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->tags.clear();
            uint32_t _size10;
            ::apache::thrift::protocol::TType _etype13;
            xfer += iprot->readSetBegin(_etype13, _size10);
            uint32_t _i14;
            for (_i14 = 0; _i14 < _size10; ++_i14)
            {
              MetricTag _elem15;
              xfer += _elem15.read(iprot);
              this->tags.insert(_elem15);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.tags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Metric::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Metric");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.metricValue) {
    xfer += oprot->writeFieldBegin("metricValue", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->metricValue.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timestamp) {
    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->timestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tags) {
    xfer += oprot->writeFieldBegin("tags", ::apache::thrift::protocol::T_SET, 4);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->tags.size()));
      std::set<MetricTag> ::const_iterator _iter16;
      for (_iter16 = this->tags.begin(); _iter16 != this->tags.end(); ++_iter16)
      {
        xfer += (*_iter16).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Metric &a, Metric &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.metricValue, b.metricValue);
  swap(a.timestamp, b.timestamp);
  swap(a.tags, b.tags);
  swap(a.__isset, b.__isset);
}

Metric::Metric(const Metric& other17) {
  name = other17.name;
  metricValue = other17.metricValue;
  timestamp = other17.timestamp;
  tags = other17.tags;
  __isset = other17.__isset;
}
Metric& Metric::operator=(const Metric& other18) {
  name = other18.name;
  metricValue = other18.metricValue;
  timestamp = other18.timestamp;
  tags = other18.tags;
  __isset = other18.__isset;
  return *this;
}
void Metric::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Metric(";
  out << "name=" << to_string(name);
  out << ", " << "metricValue="; (__isset.metricValue ? (out << to_string(metricValue)) : (out << "<null>"));
  out << ", " << "timestamp="; (__isset.timestamp ? (out << to_string(timestamp)) : (out << "<null>"));
  out << ", " << "tags="; (__isset.tags ? (out << to_string(tags)) : (out << "<null>"));
  out << ")";
}


MetricBatch::~MetricBatch() throw() {
}


void MetricBatch::__set_metrics(const std::vector<Metric> & val) {
  this->metrics = val;
}

void MetricBatch::__set_commonTags(const std::set<MetricTag> & val) {
  this->commonTags = val;
__isset.commonTags = true;
}
std::ostream& operator<<(std::ostream& out, const MetricBatch& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MetricBatch::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->metrics.clear();
            uint32_t _size19;
            ::apache::thrift::protocol::TType _etype22;
            xfer += iprot->readListBegin(_etype22, _size19);
            this->metrics.resize(_size19);
            uint32_t _i23;
            for (_i23 = 0; _i23 < _size19; ++_i23)
            {
              xfer += this->metrics[_i23].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.metrics = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->commonTags.clear();
            uint32_t _size24;
            ::apache::thrift::protocol::TType _etype27;
            xfer += iprot->readSetBegin(_etype27, _size24);
            uint32_t _i28;
            for (_i28 = 0; _i28 < _size24; ++_i28)
            {
              MetricTag _elem29;
              xfer += _elem29.read(iprot);
              this->commonTags.insert(_elem29);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.commonTags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MetricBatch::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MetricBatch");

  xfer += oprot->writeFieldBegin("metrics", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->metrics.size()));
    std::vector<Metric> ::const_iterator _iter30;
    for (_iter30 = this->metrics.begin(); _iter30 != this->metrics.end(); ++_iter30)
    {
      xfer += (*_iter30).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.commonTags) {
    xfer += oprot->writeFieldBegin("commonTags", ::apache::thrift::protocol::T_SET, 2);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->commonTags.size()));
      std::set<MetricTag> ::const_iterator _iter31;
      for (_iter31 = this->commonTags.begin(); _iter31 != this->commonTags.end(); ++_iter31)
      {
        xfer += (*_iter31).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MetricBatch &a, MetricBatch &b) {
  using ::std::swap;
  swap(a.metrics, b.metrics);
  swap(a.commonTags, b.commonTags);
  swap(a.__isset, b.__isset);
}

MetricBatch::MetricBatch(const MetricBatch& other32) {
  metrics = other32.metrics;
  commonTags = other32.commonTags;
  __isset = other32.__isset;
}
MetricBatch& MetricBatch::operator=(const MetricBatch& other33) {
  metrics = other33.metrics;
  commonTags = other33.commonTags;
  __isset = other33.__isset;
  return *this;
}
void MetricBatch::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MetricBatch(";
  out << "metrics=" << to_string(metrics);
  out << ", " << "commonTags="; (__isset.commonTags ? (out << to_string(commonTags)) : (out << "<null>"));
  out << ")";
}

}}} // namespace
